# GitHub Actions workflow to deploy Deita application using Ansible
# Runs after Docker images are built and pushed successfully

name: Deploy to Production

on:
  workflow_run:
    workflows: ["Build Backend Docker Image",]
    types: [completed]
    branches: [main]
    
concurrency:
  group: deploy-production-${{ github.ref }}
  cancel-in-progress: true

env:
  ANSIBLE_HOST_KEY_CHECKING: false

jobs:
  check-prerequisites:
    name: Check Prerequisites
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
    steps:
      - name: Check if both workflows succeeded
        id: check
        run: |
          # This job will only run if triggered by workflow_run
          # We need to verify both backend and frontend builds succeeded
          echo "should-deploy=true" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: check-prerequisites
    if: needs.check-prerequisites.outputs.should-deploy == 'true'
    environment: production
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible
      
      - name: Create SSH directory
        run: mkdir -p ~/.ssh
      
      - name: Set up SSH key
        run: |
          # Write SSH key with proper formatting and newlines
          echo "${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}" | tr -d '\r' > ~/.ssh/deploy_key
          
          # Ensure proper permissions before any SSH operations
          chmod 600 ~/.ssh/deploy_key
          chmod 700 ~/.ssh
          
          # Add known hosts with proper error handling
          ssh-keyscan -H ${{ secrets.PRODUCTION_SERVER_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not add host key"
          
          # Verify key format and permissions
          echo "SSH key permissions:"
          ls -la ~/.ssh/deploy_key
          echo "SSH key first line (should start with -----BEGIN):"
          head -n1 ~/.ssh/deploy_key
          echo "SSH key last line (should end with -----END):"
          tail -n1 ~/.ssh/deploy_key
      
      - name: Create Ansible inventory from secrets
        run: |
          cat > ansible/inventory.yml << EOF
          production:
            hosts:
              production_server:
                ansible_host: ${{ secrets.PRODUCTION_SERVER_HOST }}
                ansible_user: ${{ secrets.PRODUCTION_SERVER_USER }}
                ansible_ssh_private_key_file: ~/.ssh/deploy_key
            vars:
              ansible_python_interpreter: /usr/bin/python3
              app_directory: ${{ secrets.PRODUCTION_APP_DIRECTORY }}
              app_version: latest
          EOF
      
      - name: Create production environment file
        run: |
          cat > .env.production << EOF
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          S3_ENDPOINT=${{ secrets.S3_ENDPOINT }}
          S3_ACCESS_KEY=${{ secrets.S3_ACCESS_KEY }}
          S3_SECRET_KEY=${{ secrets.S3_SECRET_KEY }}
          S3_BUCKET_NAME=${{ secrets.S3_BUCKET_NAME }}
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_USER=${{ secrets.SMTP_USER }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          FROM_EMAIL=${{ secrets.FROM_EMAIL }}
          SECRET_KEY=${{ secrets.SECRET_KEY }}
          APP_VERSION=${{ github.sha }}
          AI_MODEL_NAME=${{ secrets.AI_MODEL_NAME }}
          AI_MODEL_ENDPOINT=${{ secrets.AI_MODEL_ENDPOINT }}
          AI_MODEL_API_KEY=${{ secrets.AI_MODEL_API_KEY }}
          EOF
      
      - name: Extract and display public key
        run: |
          # Extract public key from private key for server configuration
          echo "Extracting public key from private key..."
          ssh-keygen -y -f ~/.ssh/deploy_key > ~/.ssh/deploy_key.pub
          
          echo "=== PUBLIC KEY TO ADD TO SERVER ==="
          cat ~/.ssh/deploy_key.pub
          echo "==================================="
          
          echo ""
          echo "Key fingerprint (should match server):"
          ssh-keygen -l -f ~/.ssh/deploy_key
          
          echo ""
          echo "To manually configure the server, run these commands on your server:"
          echo "mkdir -p ~/.ssh && chmod 700 ~/.ssh"
          echo "echo '$(cat ~/.ssh/deploy_key.pub)' >> ~/.ssh/authorized_keys"
          echo "chmod 600 ~/.ssh/authorized_keys"
          echo "sudo systemctl restart ssh"
          
      - name: Test SSH connection first
        run: |
          # Test basic SSH connectivity with detailed debugging
          echo "Testing SSH connection..."
          if ssh -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 -o BatchMode=yes \
            ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} \
            "echo 'SSH connection successful'; whoami; pwd"; then
            echo "âœ… SSH key authentication working!"
          else
            echo "âŒ SSH key authentication failed"
            echo ""
            echo "The public key needs to be added to the server's ~/.ssh/authorized_keys file."
            echo "Please run these commands on your server:"
            echo ""
            echo "mkdir -p ~/.ssh && chmod 700 ~/.ssh"
            echo "echo '$(cat ~/.ssh/deploy_key.pub)' >> ~/.ssh/authorized_keys"
            echo "chmod 600 ~/.ssh/authorized_keys"
            echo ""
            echo "Or copy this public key to your server manually:"
            cat ~/.ssh/deploy_key.pub
            exit 1
          fi
      
      - name: Copy files to server
        run: |
          # Copy docker-compose.yml and .env file to server with improved error handling
          echo "Copying files to server..."
          scp -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 -o BatchMode=yes \
            docker-compose.yml .env.production \
            ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }}:${{ secrets.PRODUCTION_APP_DIRECTORY }}/
          
          # Rename .env.production to .env on server
          echo "Renaming environment file..."
          ssh -v -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 -o BatchMode=yes \
            ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} \
            "cd ${{ secrets.PRODUCTION_APP_DIRECTORY }} && mv .env.production .env && ls -la .env"
      
      - name: Test Ansible connection
        run: |
          cd ansible
          ansible production -m ping
      
      - name: Run Ansible deployment playbook
        run: |
          cd ansible
          ansible-playbook -i inventory.yml deploy.yml -v
      
      - name: Verify deployment
        run: |
          # Check if services are running
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
            -o ConnectTimeout=10 -o BatchMode=yes \
            ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_HOST }} \
            "cd ${{ secrets.PRODUCTION_APP_DIRECTORY }} && docker compose ps"
      
      - name: Test application health
        run: |
          # Wait a bit for services to fully start
          sleep 30
          
          # Test backend health endpoint
          curl -f http://${{ secrets.PRODUCTION_SERVER_HOST }}:8000/health || exit 1
          
          # Test frontend
          curl -f http://${{ secrets.PRODUCTION_SERVER_HOST }} || exit 1
      
      - name: Deployment success notification
        if: success()
        run: |
          echo "âœ… Deployment completed successfully!"
          echo "Backend: http://${{ secrets.PRODUCTION_SERVER_HOST }}:8000"
          echo "Frontend: http://${{ secrets.PRODUCTION_SERVER_HOST }}"
      
      - name: Deployment failure notification
        if: failure()
        run: |
          echo "âŒ Deployment failed!"
          echo ""
          echo "ðŸ” DIAGNOSIS: SSH key authentication is failing"
          echo "The private key is valid, but the server doesn't have the corresponding public key."
          echo ""
          echo "ðŸ”§ SOLUTION: Add the public key to your server"
          echo "Log into your server and run these commands:"
          echo ""
          echo "mkdir -p ~/.ssh && chmod 700 ~/.ssh"
          echo "cat >> ~/.ssh/authorized_keys << 'EOF'"
          echo "$(ssh-keygen -y -f ~/.ssh/deploy_key 2>/dev/null || echo 'Public key extraction failed')"
          echo "EOF"
          echo "chmod 600 ~/.ssh/authorized_keys"
          echo ""
          echo "ðŸ“‹ Additional checks:"
          echo "1. Verify SSH server config: sudo grep 'PubkeyAuthentication' /etc/ssh/sshd_config"
          echo "2. Check SSH logs: sudo journalctl -u ssh --since '5 minutes ago'"
          echo "3. Test manually: ssh -i your_private_key user@server"
          echo ""
          echo "Key fingerprint: $(ssh-keygen -l -f ~/.ssh/deploy_key 2>/dev/null || echo 'Could not get fingerprint')"